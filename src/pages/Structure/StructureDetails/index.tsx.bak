// ===== Imports =====
import { PageContainer } from "@ant-design/pro-components";
import type { Connection, Node, NodeChange, EdgeChange } from 'reactflow';
import { 
  addEdge, 
  MarkerType, 
  Edge, 
  ReactFlow, 
  Background, 
  Controls, 
  Panel,
  useNodesState,
  useEdgesState,
  ConnectionLineType,
  SmoothStepEdge,
  NodeTypes
import axios from "axios";
import "@xyflow/react/dist/style.css";
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Button, Card, Col, Row, Spin, Typography, message } from 'antd';
import { Node, Edge, NodeChange, EdgeChange, MarkerType, useReactFlow } from '@xyflow/react';
import { useStructure, useStructureById } from '@/services/structureService';
import { useAutoOrganize, useBulkUpdatePositions, useDiagramPositions, useUpdateDiagramPosition } from '@/services/diagramService';
import { useExpandedNodes } from '@/contexts/ExpandedNodesContext';
import { AppNode, CustomNodeData, LocalDiagramPosition, PositionUpdatePayload, NodePosition } from './types';
import { Structure } from '@/types/structure';

// ===== Type Definitions =====
// Renamed to avoid conflict with imported DiagramPosition
interface LocalDiagramPosition {
  content_type: string | { model: string };
  object_id: string | number;
  main_structure: string | number;
  position_x: number;
  position_y: number;
  created_at?: string;
  updated_at?: string;
}

// ===== Constants =====
// Memoize default edge options
const defaultEdgeOptions = useMemo(() => ({
  type: 'smoothstep' as const,
  animated: true,
  style: { stroke: '#94a3b8', strokeWidth: 2 },
  markerEnd: {
    type: MarkerType.ArrowClosed,
    color: '#94a3b8',
  },
}), []);

// Memoize node and edge types to prevent re-renders
const nodeTypes = useMemo(() => ({
  custom: CustomNode,
}), []);

const edgeTypes = useMemo(() => ({
  floating: FloatingEdge,
  button: CustomButtonEdge,
  smoothstep: SmoothStepEdge,
}), []);

// ===== Components =====
import StructureHierarchy from "./components/StructureHierarchy";

interface PositionUpdatePayload {
  id: string;
  position_x: number;
  position_y: number;
}

const StructureDetails: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { data, isLoading } = useStructure(id!);
  const { expandedNodes } = useExpandedNodes();
  const { setNodes } = useReactFlow();

  // Get parent ID safely, handling both object and number types
  const getParentId = () => {
    if (!data?.parent) return undefined;
    return typeof data.parent === 'object' ? data.parent.id : data.parent;
  };
  
  const parentId = getParentId();
  const { data: parentData, isLoading: isParentLoading } = useStructureById(parentId?.toString());
  const { isLoading: isAutoOrgLoading, mutate: autoOrg } = useAutoOrganize(id!);
  const { isLoading: isBulkLoading, mutate: bulk } = useBulkUpdatePositions();
  const { mutate: updateDiagramPosition } = useUpdateDiagramPosition(id!);
  
  // Get diagram positions for the current structure with loading state
  const { 
    data: diagramPositions = [], 
    isLoading: isLoadingPositions,
    isSuccess: hasPositions 
  } = useDiagramPositions(id || "");
  
  // Check if we have all the data needed to render the diagram
  const hasAllData = data && !isLoadingPositions && hasPositions && Array.isArray(diagramPositions);

  const {
    nodes,
    edges,
    setGraph,
    onNodesChange,
    onEdgesChange,
    updateNode,
    onConnect: handleConnect,
  } = useFlow();

  // Update node positions when expanded state changes
  useEffect(() => {
    if (nodes.length > 0) {
      console.log('Expanded nodes changed:', Array.from(expandedNodes));
      
      // Create a deep copy of nodes to force re-render
      const updatedNodes = nodes.map(node => {
        const isNodeExpanded = expandedNodes.has(node.id);
        console.log(`Node ${node.id} - isExpanded: ${isNodeExpanded}`);
        
        // Create a new object to ensure React detects the change
        return {
          ...node,
          position: { ...node.position }, // Create new position object
          data: {
            ...node.data,
            isExpanded: isNodeExpanded,
            // Add a timestamp to force re-render
            _lastUpdated: Date.now()
          }
        };
      });
      
      console.log('Forcing graph update with new node data');
      // Always update to ensure the diagram re-renders
      setGraph(updatedNodes, edges);
    }
  }, [expandedNodes, nodes, edges, setGraph]);
  
  // Add a key to force re-render of the ReactFlow component when expandedNodes change
  const flowKey = useMemo(() => {
    return `flow-${Array.from(expandedNodes).slice(0, 10).join('-')}`;
  }, [expandedNodes]);
  
  // Move node and edge types to the top level to prevent "used before declaration" errors
  const memoizedNodeTypes = useMemo(() => ({
    custom: CustomNode,
  }), []);

  const memoizedEdgeTypes = useMemo(() => ({
    floating: FloatingEdge,
    button: CustomButtonEdge,
    smoothstep: SmoothStepEdge,
  }), []);

  const memoizedEdgeOptions = useMemo(() => ({
    type: 'smoothstep' as const,
    animated: true,
    style: { stroke: '#94a3b8', strokeWidth: 2 },
    markerEnd: {
      type: MarkerType.ArrowClosed,
      color: '#94a3b8',
    },
  }), []);

  // ReactFlow props with proper typing
  const reactFlowProps = useMemo(() => ({
    key: flowKey,
    nodes: nodes as AppNode[],
    edges: edges,
    onNodesChange,
    onEdgesChange,
    onConnect: handleConnect,
    nodeTypes: memoizedNodeTypes,
    edgeTypes: memoizedEdgeTypes,
    defaultEdgeOptions: memoizedEdgeOptions,
    connectionLineType: ConnectionLineType.SmoothStep,
    fitView: true,
    fitViewOptions: { padding: 0.5 },
    minZoom: 0.1,
    maxZoom: 2,
    elementsSelectable: true,
    nodesConnectable: true,
    nodesDraggable: true,
    zoomOnScroll: true,
    zoomOnPinch: true,
    panOnScroll: false,
    selectionOnDrag: true,
    selectionMode: 'partial' as const,
    snapToGrid: false,
    snapGrid: [15, 15] as [number, number],
    onlyRenderVisibleElements: false,
    defaultViewport: { x: 0, y: 0, zoom: 1 },
    translateExtent: [
      [-1000, -1000],
      [2000, 2000]
    ] as [[number, number], [number, number]],
    nodeExtent: [
      [-1000, -1000],
      [2000, 2000]
    ] as [[number, number], [number, number]]

  /* backend â†’ React Flow nodes/edges */
  useEffect(() => {
    if (!hasAllData) {
      console.log('Waiting for data to be ready...');
      return;
    }
    
    console.log('Rendering diagram with data:', {
      structureId: data?.id,
      positionsCount: data?.positions?.length,
      diagramPositionsCount: diagramPositions?.length
    });

    // Ensure diagramPositions is an array before mapping
    const safeDiagramPositions = Array.isArray(diagramPositions) ? diagramPositions : [];
    
    const diagramPositionMap = new Map<string, NodePosition>();
    
    // Process positions safely with proper type assertion
    const positions = Array.isArray(diagramPositions) ? diagramPositions : [];
    positions.forEach((dp: LocalDiagramPosition) => {
      // Check if this position belongs to the current diagram
      if (dp.main_structure.toString() === data.id.toString()) {
        // Handle both string and object content_type formats
        let type = 'unknown';
        const contentType = dp.content_type;
        if (typeof contentType === 'string') {
          type = contentType.toLowerCase();
        } else if (contentType && typeof contentType === 'object' && 'model' in contentType) {
          type = String(contentType.model || '').toLowerCase();
        }
        
        const key = `${type}-${dp.object_id}`;
        diagramPositionMap.set(key, { x: dp.position_x, y: dp.position_y });
      }
    });

    // Function to get position with fallback
    const getNodePosition = (type: string, id: string | number, defaultX: number = 0, defaultY: number = 0): NodePosition => {
      // Only use positions from the current diagram
      const position = diagramPositionMap.get(`${type}-${id}`);
      return position || { x: defaultX, y: defaultY };
    };

    // Log manager and positions data for debugging
    const currentManagerId = typeof data.manager === 'number' ? data.manager : data.manager?.id;
    console.log('Current structure manager:', data.manager);
    console.log('Current structure manager_id:', currentManagerId);
    console.log('All positions:', data.positions);
    console.log('Child structures:', data.children?.map((c: Structure) => ({
      id: c.id,
      name: c.name,
      manager: c.manager
    })));

    // Filter out positions that are managers of any structure (current or children)
    const positionNodes = (data.positions || [])
      .filter((p: Position) => {
        // Check if this position is the manager of the current structure
        const isCurrentManager = currentManagerId === p.id;
        
        // Check if this position is a manager of any child structure
        const isChildManager = data.children?.some((s: Structure) => {
          const childManagerId = typeof s.manager === 'number' ? s.manager : s.manager?.id;
          return childManagerId === p.id;
        }) || false;
        
        // Log filtering decision
        if (isCurrentManager || isChildManager) {
          console.log(`Filtering out position ${p.id} (${p.title}) - isCurrentManager: ${isCurrentManager}, isChildManager: ${isChildManager}`);
        }
        
        // Only include positions that are not managers of any structure
        return !(isCurrentManager || isChildManager);
      })
      .map((p: Position, index: number) => {
        const position = getNodePosition('position', p.id.toString(), index * 200, 100);
        
        return {
          type: 'custom',
          id: `position-${p.id}`,
          position,
          data: {
            position: p,
            type: 'position',
            data: p,
          },
        };
      });

    // Add parent structure node if exists
    const parentNode = parentData ? [{
      type: 'custom',
      id: `structure-${parentData.id}`,
      position: getNodePosition('structure', parentData.id.toString(), 0, 0),
      data: {
        position: { id: parentData.id, title: parentData.name, structure: parentData.id } as Position,
        type: 'structure',
        data: parentData,
      },
      style: { border: '2px solid #1890ff' } // Highlight parent node
    }] : [];

    // Add current structure node
    const currentStructureNode = {
      type: 'custom',
      id: `structure-${data.id}`,
      position: getNodePosition('structure', data.id.toString(), 200, 200),
      data: {
        position: { id: data.id, title: data.name, structure: data.id } as Position,
        type: 'structure',
        data: data,
      },
      style: { border: '2px solid #52c41a' } // Highlight current node
    };

    // Add child structure nodes
    const childStructureNodes = (data.children || []).map((s: Structure) => ({
      type: 'custom',
      id: `structure-${s.id}`,
      position: diagramPositionMap.get(`structure-${s.id}`) || { x: 0, y: 0 },
      data: {
        position: { id: s.id, title: s.name, structure: s.id } as Position,
        type: 'structure',
        data: s,
      },
    }));

    const allNodes = [...parentNode, currentStructureNode, ...positionNodes, ...childStructureNodes];

    // Create edges for parent-child relationships
    const parentEdges = parentData ? [{
      id: `edge-${parentData.id}-${data.id}`,
      source: `structure-${parentData.id}`,
      target: `structure-${data.id}`,
      type: 'buttonedge',  // Changed from 'smoothstep' to 'buttonedge' to enable deletion
      animated: true,
      style: { stroke: '#1890ff' },
      data: { 
        structureId: id,
        // Add metadata to identify this as a structure edge
        isStructureEdge: true,
        sourceId: parentData.id,
        targetId: data.id
      }
    }] : [];

    // Create edges for current structure's children
    const childEdges = (data.children || []).map((child: Structure) => ({
      id: `edge-${data.id}-${child.id}`,
      source: `structure-${data.id}`,
      target: `structure-${child.id}`,
      type: 'buttonedge',  // Changed from 'smoothstep' to 'buttonedge' to enable deletion
      data: { 
        structureId: id,
        // Add metadata to identify this as a structure edge
        isStructureEdge: true,
        sourceId: data.id,
        targetId: child.id
      },
    }));

    // Combine with existing edges (position edges)
    const positionEdges = (data.edges || []).map((e: OrganigramEdge) => ({
      id: String(e.id),
      source: `${e.source.type}-${e.source.id}`,
      target: `${e.target.type}-${e.target.id}`,
      type: 'buttonedge',
      data: { 
        structureId: id,
        // Add metadata to identify this as a position edge
        isPositionEdge: true
      },
    }));

    const allEdges = [
      ...parentEdges,
      ...childEdges,
      ...positionEdges
    ];

    console.log('Updating graph with:', {
      nodes: allNodes.length,
      edges: allEdges.length,
      firstNode: allNodes[0],
      firstEdge: allEdges[0]
    });
    
    setGraph(allNodes, allEdges);
  }, [data, diagramPositions, setGraph, hasAllData]);

  // Update node positions when diagram positions change
  useEffect(() => {
    if (!hasAllData || !Array.isArray(diagramPositions)) return;

    // Create a map of node positions from the diagram positions
    const positionMap = new Map<string, { x: number; y: number }>();
    (diagramPositions as LocalDiagramPosition[]).forEach((pos) => {
      positionMap.set(pos.object_id.toString(), {
        x: pos.position_x,
        y: pos.position_y,
      });
    });

    // Update node positions
    setNodes((nds: AppNode[]) =>
      nds.map((node) => {
        const position = positionMap.get(node.id);
        if (position) {
          return {
            ...node,
            position,
          };
        }
        return node;
      })
    );
  }, [diagramPositions, hasAllData, setNodes]);

  const handleBulkUpdate = async (positions: PositionUpdatePayload[]) => {
    try {
      await bulk(positions);
      message.success('Positions updated successfully');
    } catch (error) {
      message.error('Failed to update positions');
    }
  };

  const handleAutoOrganize = useCallback(async () => {
    try {
      await autoOrg();
      message.success('Organization completed successfully');
    } catch (error) {
      message.error('Failed to auto-organize');
    }
  }, [autoOrg]);

  // Save node positions to the server
  const handleNodeDragStop = useCallback(
    (event: any, node: Node) => {
      if (!id || !data) return;

      if (!data) return;
      
      const positionUpdate: PositionUpdatePayload = {
        contentObject: node.data?.content_type || 'position',
        position: {
          x: node.position.x,
          y: node.position.y
        },
        main_structure: data.id,
        object_id: node.id,
        position_x: node.position.x,
        position_y: node.position.y,
        id: node.id,
        content_type: node.data?.content_type || 'position',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      updateDiagramPosition(positionUpdate);
        try {
          console.log('Updating position node:', { 
            positionId: id, 
            position: node.position,
            mainStructureId: data.id
          });
          
          // Update diagram position for position node
          await updateDiagramPosition({
            contentObject: {
              id: parseInt(id),
              type: 'position'  // This will be used to look up the content type on the backend
            },
            main_structure: data.id,
            position: node.position
          });
          
          console.log('Successfully updated position node position');
        } catch (error) {
          console.error('Error updating position node position:', error);
          message.error('Failed to save position');
        }
      } else if (type === 'structure' && id) {
        try {
          console.log('Updating structure node position:', { 
            structureId: id, 
            position: node.position,
            mainStructureId: data.id
          });
          
          // Update diagram position for structure
          await updateDiagramPosition({
            contentObject: {
              id: parseInt(id),
              type: 'structure'  // This will be used to look up the content type on the backend
            },
            main_structure: data.id,
            position: node.position
          });
          
          console.log('Successfully updated structure position');
        } catch (error) {
          console.error('Error updating diagram position:', error);
          message.error('Failed to save position');
        }
      }
    },
    [updateNode, updateDiagramPosition, data?.id]
  );

  const { mutate: createEdge } = useCreateEdge(id!);

  const edgeTypes = {
    buttonedge: CustomButtonEdge,
    smoothstep: SmoothStepEdge,
    default: SmoothStepEdge,
  };

  const nodeTypes: NodeTypes = {
    custom: CustomNode as any, // Type assertion to handle the type mismatch
  };
  
  const connectionLineStyle = {
    stroke: '#b1b1b7',
    strokeWidth: 2,
  };

  const defaultEdgeOptions = {
    type: 'smoothstep',
    style: { stroke: '#b1b1b7', strokeWidth: 2 },
    markerEnd: {
      type: MarkerType.ArrowClosed,
      color: '#b1b1b7',
    },
    interactionWidth: 20,
  };

  const onConnect = useCallback(
    (connection: Connection) => {
      const parseNodeId = (nodeId: string | null) => {
        if (!nodeId) return null;
        const [type, id] = nodeId.split('-');
        if (!type || !id) return null;
        return { type, id: Number(id) };
      };

      const sourceNodeInfo = parseNodeId(connection.source);
      const targetNodeInfo = parseNodeId(connection.target);

      if (!sourceNodeInfo || !targetNodeInfo) {
        console.error('Invalid connection:', connection);
        return;
      }

      createEdge(
        {
          structure: Number(id!),
          source: { type: sourceNodeInfo.type as any, id: sourceNodeInfo.id, name: '' },
          target: { type: targetNodeInfo.type as any, id: targetNodeInfo.id, name: '' },
          edge_type: 'buttonedge',
        },
        {
          onError: (error: any) => {
            console.error('Failed to create edge:', error);
            message.error(
              error.response?.data?.non_field_errors?.[0] ||
              error.response?.data?.detail ||
              'Failed to create connection'
            );
          },
        }
      );
    },
    [createEdge, id],
  );

  const { toggleCollapse } = useFlow();

  // Convert structure data to tree format
  const convertToTreeData = (structure: Structure | null): any => {
    if (!structure) return [];

    const treeNode = {
      title: (
        <span style={{ fontWeight: structure.id === data?.id ? 'bold' : 'normal' }}>
          {structure.name}
        </span>
      ),
      key: structure.id.toString(),
      isLeaf: !structure.children || structure.children.length === 0,
      children: structure.children?.map(convertToTreeData) || [],
    };

    return treeNode;
  };

  // Get the complete hierarchy including the main structure
  const getCompleteHierarchy = (structure: Structure | null) => {
    if (!structure) return [];
    
    // Check if parent exists and is a Structure object (not just an ID)
    const hasParentObject = structure.parent && typeof structure.parent === 'object';
    
    // If this structure has a parent object (not just an ID), we might want to include it
    // For now, we'll just show the current structure and its children
    // In a real app, you might want to fetch the full hierarchy
    return [convertToTreeData(structure)];
  };

  // Get tree data, handling undefined case
  const treeData = data ? getCompleteHierarchy(data) : [];

  // Handle tree node selection
  const handleNodeSelect = (selectedKeys: React.Key[]) => {
    if (selectedKeys.length > 0) {
      navigate(`/structures/${selectedKeys[0]}`);
    }
  };

  const handleShowParent = (parentId: string) => {
    navigate(`/structures/${parentId}`);
  };

  if (!data) {
    return (
      <PageContainer>
        <div style={{ textAlign: 'center', padding: '40px 20px' }}>
          <div>Loading structure data...</div>
        </div>
      </PageContainer>
    );
  }

  return (
    <PageContainer
      contentWidth="Fluid"
      header={{
        title: data?.name || 'Structure',
        extra: [
          <Button
            key="auto-organize"
            type="primary"
            onClick={handleAutoOrganize}
            loading={isAutoOrgLoading}
            disabled={isLoading || isBulkLoading}
          >
            Auto-Organize
          </Button>,
        ],
      }}
    >
      <Row gutter={16}>
        <Col span={5}>
          <StructureHierarchy
            data={data}
            currentStructureId={data?.id?.toString()}
            onSelect={handleNodeSelect}
            onShowParent={handleShowParent}
          />
        </Col>
        <Col span={19}>
          <div style={{ 
            height: 'calc(100vh - 250px)', 
            width: '100%', 
            border: '1px solid #f0f0f0', 
            borderRadius: 4,
            position: 'relative'
          }}>
            {!isDataReady ? (
              <div style={{
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                height: '100%',
                color: '#666',
                fontSize: '16px'
              }}>
                {isLoadingPositions ? 'Loading diagram positions...' : 'Preparing diagram...'}
              </div>
            ) : (
              <ReactFlow
                key={flowKey} 
                nodes={nodes}
                edges={edges}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                onConnect={handleConnect}
                onNodeDragStop={onNodeDragStop}
                nodeTypes={nodeTypes}
                edgeTypes={edgeTypes}
                connectionLineType={ConnectionLineType.SmoothStep}
                fitView
                panOnDrag
                minZoom={0.1}
                maxZoom={2}
              >
                <Background />
                <Controls />
                <Panel position="top-right">
                  <SearchControl />
                </Panel>
                <Panel position="bottom-right">
                  <ZoomSlider />
                </Panel>
              </ReactFlow>
            )}
          </div>
        </Col>
      </Row>
    </PageContainer>
  );
};
